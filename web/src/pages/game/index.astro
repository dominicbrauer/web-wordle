---
import DigitalKeyboard from "../../components/game/DigitalKeyboard.astro"
import WordGrid from "../../components/game/WordGrid.astro"
import Layout from "../../layouts/Layout.astro"
---

<Layout>
  <WordGrid />
  <DigitalKeyboard />
</Layout>

<script>
  import { KEYBOARD_KEYS } from "../../lib/constants";
  import type { GameSession, Guess, Char } from "../../lib/gameSession";
  import { requestGameSession } from "../../scripts/requestGameSession";
  import { guessRequest } from "../../scripts/guessRequest";
  import { range } from "../../lib/helpers";
  import { Cursor } from "../../lib/cursor"

  let gameSession: GameSession = await requestGameSession();

  const charTiles = document.querySelectorAll('.char-tile') as NodeListOf<HTMLDivElement>;
  const charTileLabels = document.querySelectorAll('.char-tile-label') as NodeListOf<HTMLSpanElement>;
  const pageBody = document.querySelector('body') as HTMLBodyElement;
  const cursor: Cursor = new Cursor(0, gameSession.guesses_used, false, false);

  /**
   * Activates the current row based on `cursor.y`
   * and deactivates all other rows.
   */
  function shiftRow(): void {
    charTiles.forEach(tile => {
      tile.classList.remove('active');
    });
    for (const i of range(5)) {
      charTiles[cursor.coordToIdx(i, undefined)].classList.add('active');
    }

    charTiles?.forEach((tile, idx) => {
      tile.addEventListener('click', () => {
        if (!tile.classList.contains('active')) return;
        cursor.selfSet = true;
        cursor.oob = false;
        removeSelectionClass();
        [cursor.x, cursor.y] = cursor.idxToCoord(idx);
        addSelectionClass();
      });
    });
  }


  function validKeyInput(key: string): boolean {
    let found: boolean = false;
    KEYBOARD_KEYS.push(['ENTER', 'BACKSPACE']);
    KEYBOARD_KEYS?.forEach(row => {
      if (row.includes(key)) found = true;
    });
    return found;
  }


  function addSelectionClass(): void {
    charTiles[cursor.getPos()]?.classList.add('char-tile-selected');
  }
  function removeSelectionClass(): void {
    charTiles[cursor.getPos()]?.classList.remove('char-tile-selected');
  }


  function handleKeyboardInput(key: string): void {
    switch(key) {
      case 'ENTER': handleEnterInput(); break;
      case 'BACKSPACE': handleBackspaceInput(); break;
      default: handleCharacterInput(key); break;
    }
    cursor.selfSet = false;
  }


  function handleBackspaceInput(): void {
    if (cursor.selfSet || charTileLabels[cursor.getPos()].textContent !== '' || cursor.oob) {
      cursor.oob = false;
      charTileLabels[cursor.getPos()].textContent = '';
      addSelectionClass();
    } else if (cursor.x > 0) {
      charTileLabels[cursor.getPos()-1].textContent = '';
      removeSelectionClass();
      cursor.x--;
      addSelectionClass();
    }
  }


  function handleCharacterInput(key: string): void {
    if (cursor.oob) return;
    charTileLabels[cursor.getPos()].textContent = key.toUpperCase();
    if (cursor.x <= 3) {
      removeSelectionClass();
      cursor.x++;
      addSelectionClass();
    } else {
      cursor.oob = true;
      removeSelectionClass();
    }
  }


  async function handleEnterInput(): Promise<void> {
    const characters: string[] = [];
    for (const i of range(5)) {
      const divText: string | null = charTileLabels[cursor.coordToIdx(i, undefined)].textContent;
      characters.push(divText !== null ? divText : "");
    }
    if (characters.includes('')) {
      // Invalid Enter handling...
      console.log("Not all characters are set!");
      return;
    }
    const word: string = characters.join('').toLowerCase();
    gameSession.current_guess = word;
    gameSession.status = "submit-guess";
    gameSession.current_guess_valid = false;

    gameSession = await guessRequest(gameSession);
    updateGameState();
  }


  function charHighlighting(): void {
    for (const i of range(gameSession.guesses_used)) {
      for (const j of range(5)) {
        const charScoring = gameSession.guesses[i].character_info[j].scoring;
        switch(charScoring) {
          case "green": {
            charTiles[cursor.coordToIdx(j, i)].classList.add('char-feedback-green');
            break;
          }
          case "yellow": {
            charTiles[cursor.coordToIdx(j, i)].classList.add('char-feedback-yellow');
            break;
          }
          default: {
            charTiles[cursor.coordToIdx(j, i)].classList.add('char-feedback-gray');
            break;
          }
        }
      }
    }
  }


  function updateGameState(): void {
    removeSelectionClass();
    cursor.x = 0;
    cursor.y = gameSession.guesses_used;
    cursor.selfSet = false;
    cursor.oob = false;
    shiftRow();
    addSelectionClass();
    charHighlighting();

    gameSession?.guesses?.forEach((guess, rowIdx) => {
      for (const i of range(5)) {
        charTileLabels[cursor.coordToIdx(i, rowIdx)].textContent = guess.word.charAt(i).toUpperCase();
      }
    });
  }


  pageBody?.addEventListener('keydown', (event) => {
    const keyInput: string = event.key.toUpperCase();
    if (!validKeyInput(keyInput)) return;
    handleKeyboardInput(keyInput);
  });

  updateGameState();
</script>