---
import Assistant from "../../components/game/Assistant.astro"
import DigitalKeyboard from "../../components/game/DigitalKeyboard.astro"
import LogoSection from "../../components/game/LogoSection.astro"
import ScoreBoard from "../../components/game/ScoreBoard.astro"
import WordGrid from "../../components/game/WordGrid.astro"
import Layout from "../../layouts/Layout.astro"
---

<Layout title="Classic Game">
  <div class="game-frame">
    <div class="upper-area">
      <div class="side left">
        <LogoSection />
        <Assistant />
      </div>
      <WordGrid />
      <div class="side right">
        <ScoreBoard />
      </div>      
    </div>
    
    <DigitalKeyboard />
  </div>
</Layout>

<style>
  .game-frame {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    width: fit-content;
    height: 100%;
    margin: 1rem auto;
    gap: 1rem;
  }

  .upper-area {
    display: flex;
    flex-direction: row;
    height: fit-content;
    justify-content: center;
    gap: 2rem;
  }

  .side {
    display: flex;
    padding: 1.5rem;
    width: 400px;
    height: 100%;
  }

  .side.left {
    flex-direction: column;
    gap: 1rem;
    justify-content: center;
  }

  .side.right {
    align-items: center;
    justify-content: left;
  }

  body {
    display: flex;
    flex-direction: column;
  }
</style>

<script>
  import { ROW_MULTIPLIERS } from "../../lib/config";
  import { GUESSES, KEYBOARD_KEYS, WORD_LENGTH, GRAY_TILE_VALUE, YELLOW_TILE_VALUE, GREEN_TILE_VALUE } from "../../lib/config";
  import type { GameSession} from "../../lib/gameSession";
  import { addScores } from "../../lib/helpers";
  import { submitGuess, requestGameSession, requestNextGame, submitLostGame } from "../../scripts/gameRequests"

  const pageBody = document.querySelector('body') as HTMLBodyElement;

  let gameSession: GameSession;
  try {
    gameSession = await requestGameSession();
  } catch (error) {
    updateAssistantMessage("I couldn't connect to the server!");
  }

  pageBody?.addEventListener('keydown', (e) => {
    const keyInput: string = e.key.toUpperCase();

    if (!validKeyInput(keyInput)) return;
    const event = new CustomEvent("keyInput", {
      detail: {
        keyInput: keyInput,
      }
    });
    window.dispatchEvent(event);
  });

  window.addEventListener("submitGuess", async (e) => {
    gameSession.current_guess = (e as CustomEvent).detail.word;
    gameSession.status = "submit_guess";

    gameSession = await submitGuess(gameSession);
    triggerUpdate();
  });

  window.addEventListener("analyseGameState", () => {
    analyseGameState();
  });

  /**
   * Updates the shown text in the Assistant container.
   * @param msg Message to display
   */
  function updateAssistantMessage(msg: string) {
    window.dispatchEvent(new CustomEvent("showAssistantMessage", {
      detail: {msg: msg}
    }));
  }

  /**
   * Validates an input key
   * @param key - keyboard key
   * @returns Whether the key is valid
   */
   function validKeyInput(key: string): boolean {
    let found: boolean = false;

    KEYBOARD_KEYS?.forEach(row => {
      if (row.includes(key) || ['ENTER', 'BACKSPACE'].includes(key)) found = true;
    });

    return found;
  }

  /**
   * Transmits the current gameSession as an event.
   */
  function triggerUpdate() {
    // Invalid guess
    if (!gameSession.current_guess_valid) {
      window.dispatchEvent(new CustomEvent("headShake", {
        detail: {row: gameSession.guesses_used}
      }));
    }

    if (gameSession.guesses_used < GUESSES) {
      window.dispatchEvent(new CustomEvent("initWordRows", {
        detail: {gameSession: gameSession}
      }));
    }

    window.dispatchEvent(new CustomEvent("updateWordGrid", {
      detail: {gameSession: gameSession}
    }));

    window.dispatchEvent(new CustomEvent("updateDigitalKeyboard", {
      detail: {gameSession: gameSession}
    }));

    window.dispatchEvent(new CustomEvent("updateScoreBoard", {
      detail: {gameSession: gameSession, scores: calcScores()}
    }));
  }

  /**
   * Calculates the scores for each guess
   * based on the feedback colors.
   * @return 2D-array with score values
   */
  function calcScores(): Array<Array<number>> {
    // Empty scores 2D-array
    const scores: number[][] = Array.from({ length: GUESSES }, () =>
      Array(WORD_LENGTH).fill(0)
    );
    
    gameSession.guesses?.forEach((guess, i) => {
      const colors: Array<string> = [];
      
      // Gets the colors of a word
      guess.character_info.forEach(char => {
        colors.push(char.scoring);
      });

      // Colors and their score values
      const colorMap: Record<string, number> = {
        gray: GRAY_TILE_VALUE,
        yellow: YELLOW_TILE_VALUE,
        green: GREEN_TILE_VALUE
      };

      // Adds score values to scores[]
      colors?.forEach((color, j) => {
        scores[i][j] = colorMap[color];
      });
    });

    return scores;
  }

  /**
   * Analyses the current game state for
   * winning/losing conditions.
   */
  async function analyseGameState() {
    // Correct guess: Win
    if (gameSession.guesses_used > 0 && gameSession.guesses[gameSession.guesses_used - 1].was_correct) {
      await handleWin();
      return;
    }

    // No guesses left: Lose
    if (gameSession.guesses_used >= GUESSES) {
      await handleLose();
      return;
    }
  }

  /**
   * Handles winning the game (correct word).
   */
  async function handleWin() {
    const newScores: number[] = gameSession.scores;
    const score = addScores(calcScores())
      * (1 + gameSession.current_game_index * 0.1)
      * ROW_MULTIPLIERS[gameSession.guesses_used - 1];
    newScores.push(Math.floor(score));

    const sendGameSession: GameSession = {
      status: "request_next_game",
      guesses_used: gameSession.guesses_used,
      current_guess: gameSession.current_guess,
      current_guess_valid: gameSession.current_guess_valid,
      guesses: gameSession.guesses,
      current_game_index: gameSession.current_game_index,
      scores: newScores
    };

    gameSession = await requestNextGame(sendGameSession);

    triggerUpdate();

    window.dispatchEvent(new CustomEvent("resetWordGrid", {
      detail: {gameSession: gameSession}
    }));
  }

  /**
   * Handles losing the game (all guesses used).
   */
  async function handleLose() {
    window.dispatchEvent(new CustomEvent("showAssistantMessage", {
      detail: {msg: "Oh no, you lost! You have no guesses left... Next time you'll win!"}
    }));

    const newScores: number[] = gameSession.scores;
    const score = addScores(calcScores())
      * (1 + gameSession.current_game_index * 0.1)
      * ROW_MULTIPLIERS[gameSession.guesses_used - 1];
    newScores.push(Math.floor(score));

    const sendGameSession: GameSession = {
      status: "game_over",
      guesses_used: gameSession.guesses_used,
      current_guess: gameSession.current_guess,
      current_guess_valid: gameSession.current_guess_valid,
      guesses: gameSession.guesses,
      current_game_index: gameSession.current_game_index,
      scores: newScores
    };

    await submitLostGame(sendGameSession);

    alert("No more guesses left!");
    window.location.href = "http://localhost:4321";
  }

  triggerUpdate();
  analyseGameState();
</script>