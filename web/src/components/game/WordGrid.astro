---
import WordRow from "./wordgrid/WordRow.astro";
---

<div class="word-grid">
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
</div>

<style>
  .word-grid {
    position: relative;
    display: flex;
    flex-direction: column;
    background-color: var(--background);
    width: fit-content;
    height: fit-content;
    margin: 0 auto;
  }

  .game-won {
    border: 4px solid var(--green);
  }
  .game-lost {
    border: 4px solid var(--red);
  }
</style>

<script>
  ////////// Imports //////////
  import { Cursor } from "../../lib/cursor";
  import type { GameSession } from "../../lib/gameSession";
  import { range } from "../../lib/helpers";
  import { flipTile } from "../../scripts/flipTileAnimation"
  ////////// Imports //////////


  ////////// Variables //////////
  const charTiles = document.querySelectorAll<HTMLDivElement>('.char-tile');
  const charTileLabels = document.querySelectorAll<HTMLSpanElement>('.char-tile-label');
  let gameSession: GameSession;
  const cursor: Cursor = new Cursor(0, 0, false, false);
  ////////// Variables //////////


  ////////// Event Listeners //////////
  // Connection to exchange the gameSession after each fetch
  window.addEventListener("transmitCurrentGameState", (e) => {
    const event = e as CustomEvent;
  
    gameSession = event.detail.gameSession;
    updateGame();
  });


  // Exchanges the read keyboard key
  window.addEventListener("keyInput", (e) => {
    const event = e as CustomEvent;

    handleKeyboardInput(event.detail.keyInput);
  });


  // Makes every char tile clickable
  charTiles?.forEach((tile, idx) => {
    tile.addEventListener('click', () => {
      if (!tile.classList.contains('active')) return;
      
      cursor.selfSet = true;
      cursor.oob = false;
      cursor.removeSelection(charTiles);
      [cursor.x, cursor.y] = cursor.idxToCoord(idx);
      cursor.addSelection(charTiles);
    });
  });
  ////////// Event Listeners //////////


  ////////// Functions //////////
  /**
   * Color codes the character tiles in the word grid.
   */
  function charHighlighting(): void {
    for (const i of range(gameSession.guesses_used)) {
      for (const j of range(5)) {
        const charScoring = gameSession.guesses[i].character_info[j].scoring;
        const tile = charTiles[cursor.coordToIdx(j, i)];

        const classMap: Record<string, string> = {
          green: 'char-feedback-green',
          yellow: 'char-feedback-yellow',
        };

        tile.classList.add(classMap[charScoring] || 'char-feedback-gray');
      }
    }
  }


  /**
   * Redirects a keyboard input based on its type.
   * @param key A keyboard key
   */
  function handleKeyboardInput(key: string): void {
    switch(key) {
      case 'ENTER': handleEnterInput(); break;
      case 'BACKSPACE': handleBackspaceInput(); break;
      default: handleCharacterInput(key); break;
    }
    // cursor.selfSet = false;
  }


  /**
   * Performs character removal if possible.
   */
  function handleBackspaceInput(): void {
    if ((cursor.selfSet || cursor.oob) && charTileLabels[cursor.getPos()].textContent !== '') {
      cursor.oob = false;
      charTileLabels[cursor.getPos()].textContent = '';
      cursor.addSelection(charTiles);
    } else if (cursor.x > 0) {
      charTileLabels[cursor.getPos()-1].textContent = '';
      cursor.removeSelection(charTiles);
      cursor.x--;
      cursor.addSelection(charTiles);
    } else {
      requestHeadShake();
    }
  }


  /**
   * Inserts a keyboard key into the word grid.
   * @param key 
   */
  function handleCharacterInput(key: string): void {
    if (cursor.oob) {
      requestHeadShake();
      return;
    }
    charTileLabels[cursor.getPos()].textContent = key.toUpperCase();
    if (cursor.x <= 3) {
      cursor.removeSelection(charTiles);
      cursor.x++;
      cursor.addSelection(charTiles);
    } else {
      cursor.oob = true;
      cursor.removeSelection(charTiles);
    }
  }


  /**
   * Reads a word input in the current row and transmits it in a dispatch event.
   */
  function handleEnterInput(): void {
    const characters: string[] = [];

    for (const i of range(5)) {
      const divText: string | null = charTileLabels[cursor.coordToIdx(i, undefined)].textContent;
      characters.push(divText !== null ? divText : '');
    }
    if (characters.includes('')) {
      requestHeadShake();
      return;
    }
    
    const word: string = characters.join('').toLowerCase();
    sendWord(word);
  }


  /**
   * Dispatch an event to fetch a guessRequest.
   * @param word Five-letter word guess
   */
  function sendWord(word: string): void {
    const event = new CustomEvent("guessRequest", {
      detail: {
        word: word,
      }
    });
    window.dispatchEvent(event);
  }


  /**
   * Dispatches the event to make the current wordRow headshake.
   */
  function requestHeadShake(): void {
    const event = new CustomEvent("headShake", {
      detail: {
        row: cursor.y,
      }
    });
    window.dispatchEvent(event);
  }


  /**
   * Initiliazes the word grid after a new gameSession is available.
   */
  function initGameState(): void {
    if (gameSession.status == "return_feedback" && !gameSession.current_guess_valid) {
      requestHeadShake();
      return;
    }

    if (gameSession.current_guess_valid) {
      cursor.x = 0;
      cursor.oob = false;
      cursor.selfSet = false;
    }

    cursor.y = gameSession.guesses_used;
    cursor.addSelection(charTiles);
    charHighlighting();
    gameSession?.guesses?.forEach((guess, rowIdx) => {
      for (const i of range(5)) {
        charTileLabels[cursor.coordToIdx(i, rowIdx)].textContent = guess.word.charAt(i).toUpperCase();
      }
    });
  }


  /**
   * First checks if the win/lose condition is met, otherwise it updates the word grid.
   */
  function updateGame(): void {
    // Correct guess: Win
    if (gameSession.guesses_used > 0) {
      if (gameSession.guesses[gameSession.guesses_used - 1].was_correct) {
        document.querySelector<HTMLDivElement>('.word-grid')?.classList.add('game-won');
        return;
      }
    }
    
    // No guesses left: Lose
    if (gameSession.guesses_used > 5) {
      document.querySelector<HTMLDivElement>('.word-grid')?.classList.add('game-lost');
      return;
    }

    initGameState();
  }
  ////////// Functions //////////
</script>