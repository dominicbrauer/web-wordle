---
import WordRow from "./wordgrid/WordRow.astro";
import { GUESSES } from "../../lib/config";
---

<div class="word-grid">
  {Array.from({ length: GUESSES }).map(() => (
    <WordRow />
  ))}
</div>

<style>
  .word-grid {
    position: relative;
    display: flex;
    flex-direction: column;
    background-color: var(--background);
    width: fit-content;
    height: fit-content;
  }

  .game-won {
    border: 4px solid var(--green);
  }
  .game-lost {
    border: 4px solid var(--red);
  }
</style>

<script>
  import { WORD_LENGTH, GUESSES, GRAY_TILE_VALUE, YELLOW_TILE_VALUE, GREEN_TILE_VALUE } from "../../lib/config";
  import { Cursor } from "../../lib/cursor";
  import type { GameSession } from "../../lib/gameSession";
  import { range } from "../../lib/helpers";
  import { flipTile } from "../../scripts/flipTileAnimation"


  const charTiles = document.querySelectorAll<HTMLDivElement>('.char-tile');
  const charTileLabels = document.querySelectorAll<HTMLSpanElement>('.char-tile-label');
  const scoreLabels = document.querySelectorAll<HTMLSpanElement>('.score');
  let gameSession: GameSession;
  const cursor: Cursor = new Cursor(0, 0, false, false);
  let blockUserInput: boolean = false;


  // Connection to exchange the gameSession after each fetch
  window.addEventListener("updateWordGrid", async (e) => {
    gameSession = (e as CustomEvent).detail.gameSession;
    await updateGame();

    // Requests a win/lose evaluation
    const analyseGameState = new CustomEvent("analyseGameState");
    window.dispatchEvent(analyseGameState);

    blockUserInput = false;
  });

  // Connection to reset the word grid
  window.addEventListener("resetWordGrid", (e) => {
    gameSession = (e as CustomEvent).detail.gameSession;
    charTiles.forEach(charTile => {
      flipTile(charTile, "reset");
    });
    updateGame();
  });


  // Exchanges the read keyboard key
  window.addEventListener('keyInput', (e) => {
    if (blockUserInput) return;

    handleKeyboardInput((e as CustomEvent).detail.keyInput);
  });


  // Makes every char tile clickable
  charTiles?.forEach((tile, idx) => {
    tile.addEventListener('click', () => {
      if (blockUserInput) return;
      if (!tile.classList.contains('active')) return;
      
      cursor.selfSet = true;
      cursor.oob = false;
      cursor.removeSelection(charTiles);
      [cursor.x, cursor.y] = cursor.idxToCoord(idx);
      cursor.addSelection(charTiles);
    });
  });


  /**
   * Color codes the character tiles in the word grid.
   */
  async function charHighlighting(): Promise<void> {
    if (gameSession.status == "return_feedback") {
      for (const i of range(WORD_LENGTH)) {
        const charIdx: number = cursor.coordToIdx(i, gameSession.guesses_used - 1);
        const color: string = gameSession.guesses[gameSession.guesses_used - 1].character_info[i].scoring;

        await flipTile(charTiles[charIdx], color);
      }
      return;
    }

    for (const i of range(gameSession.guesses_used)) {
      for (const j of range(WORD_LENGTH)) {
        const charScoring = gameSession.guesses[i].character_info[j].scoring;
        const tile = charTiles[cursor.coordToIdx(j, i)];

        const classMap: Record<string, string> = {
          green: 'char-feedback-green',
          yellow: 'char-feedback-yellow',
        };

        tile.classList.add(classMap[charScoring] || 'char-feedback-gray');
      }
    }
  }


  /**
   * Redirects a keyboard input based on its type.
   * @param key A keyboard key
   */
  function handleKeyboardInput(key: string): void {
    switch(key) {
      case 'ENTER': handleEnterInput(); break;
      case 'BACKSPACE': handleBackspaceInput(); break;
      default: handleCharacterInput(key); break;
    }
    // cursor.selfSet = false;
  }


  /**
   * Performs character removal if possible.
   */
  function handleBackspaceInput(): void {
    if ((cursor.selfSet || cursor.oob) && charTileLabels[cursor.getPos()].textContent !== '') {
      cursor.oob = false;
      charTileLabels[cursor.getPos()].textContent = '';
      cursor.addSelection(charTiles);
    } else if (cursor.x > 0) {
      charTileLabels[cursor.getPos()-1].textContent = '';
      cursor.removeSelection(charTiles);
      cursor.x--;
      cursor.addSelection(charTiles);
    } else {
      requestHeadShake();
    }
  }


  /**
   * Inserts a keyboard key into the word grid.
   * @param key 
   */
  function handleCharacterInput(key: string): void {
    if (cursor.oob) {
      requestHeadShake();
      return;
    }
    charTileLabels[cursor.getPos()].textContent = key.toUpperCase();
    if (cursor.x < WORD_LENGTH - 1) {
      cursor.removeSelection(charTiles);
      cursor.x++;
      cursor.addSelection(charTiles);
    } else {
      cursor.oob = true;
      cursor.removeSelection(charTiles);
    }
  }


  /**
   * Reads the characters in the current row.
   * If every tile in the row contains a character,
   * the guess is sent to the server.
   */
  function handleEnterInput(): void {
    const characters: string[] = [];

    for (const i of range(WORD_LENGTH)) {
      const divText: string | null = charTileLabels[cursor.coordToIdx(i, undefined)].textContent;
      characters.push(divText !== null ? divText : '');
    }
    if (characters.includes('')) {
      requestHeadShake();
      return;
    }
    
    const word: string = characters.join('').toLowerCase();
    sendWord(word);
  }


  /**
   * Dispatch an event to fetch a guessRequest.
   * @param word Five-letter word guess
   */
  function sendWord(word: string): void {
    blockUserInput = true;
    
    const event = new CustomEvent("guessRequest", {
      detail: {
        word: word,
      }
    });
    window.dispatchEvent(event);
  }


  /**
   * Requests the current row to run its headshake animation.
   */
  function requestHeadShake(): void {
    const event = new CustomEvent("headShake", {
      detail: {
        row: cursor.y,
      }
    });
    window.dispatchEvent(event);
  }


  /**
   * Updates all word grid components.
   */
  async function updateGame(): Promise<void> {
    if (gameSession.guesses_used < GUESSES) {
      const updateWordRows = new CustomEvent("updateWordRows", {
        detail: {gameSession: gameSession}
      });
      window.dispatchEvent(updateWordRows);
    }
    
    if (gameSession.status == "return_feedback" && !gameSession.current_guess_valid) {
      requestHeadShake();
      return;
    }

    await charHighlighting();

    if (gameSession.current_guess_valid) {
      cursor.x = 0;
      cursor.oob = false;
      cursor.selfSet = false;
    }

    cursor.y = gameSession.guesses_used;
    cursor.addSelection(charTiles);
    gameSession?.guesses?.forEach((guess, rowIdx) => {
      for (const i of range(WORD_LENGTH)) {
        charTileLabels[cursor.coordToIdx(i, rowIdx)].textContent = guess.word.charAt(i).toUpperCase();
      }
    });

    calcScores();
  }


  /**
   * 
   */
  function calcScores(): void {
    gameSession.guesses?.forEach((guess, index) => {
      const colors: Array<string> = [];

      guess.character_info.forEach(char => {
        colors.push(char.scoring);
      });

      const grays: number = colors.filter(element => element == "gray").length;
      const yellows: number = colors.filter(element => element == "yellow").length;
      const greens: number = colors.filter(element => element == "green").length;

      const score = GRAY_TILE_VALUE * grays + YELLOW_TILE_VALUE * yellows + GREEN_TILE_VALUE * greens;

      scoreLabels[index].textContent = score.toString() + 'P';
      gameSession.scores[index] = score;
    });
  }
</script>