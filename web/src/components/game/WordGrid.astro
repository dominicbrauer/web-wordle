---
import WordRow from "./wordgrid/WordRow.astro";
import { GUESSES } from "../../lib/config";
---

<div class="word-grid">
  {Array.from({ length: GUESSES }).map(() => (
    <WordRow />
  ))}
</div>

<style>
  .word-grid {
    position: relative;
    display: flex;
    flex-direction: column;
    background-color: var(--background);
    width: fit-content;
    height: fit-content;
  }

  .game-won {
    border: 4px solid var(--green);
  }
  .game-lost {
    border: 4px solid var(--red);
  }
</style>

<script>
  import { WORD_LENGTH, GUESSES } from "../../lib/config";
  import { Cursor } from "../../lib/cursor";
  import type { GameSession } from "../../lib/gameSession";
  import { range } from "../../lib/helpers";
  import { flipTile } from "../../scripts/flipTileAnimation"


  const charTiles = document.querySelectorAll<HTMLDivElement>('.char-tile');
  const charTileLabels = document.querySelectorAll<HTMLSpanElement>('.char-tile-label');
  let gameSession: GameSession;
  const cursor: Cursor = new Cursor(0, 0, false, false);
  let blockUserInput: boolean = false;


  // Connection to exchange the gameSession after each fetch
  window.addEventListener("updateWordGrid", async (e) => {
    gameSession = (e as CustomEvent).detail.gameSession;
    await updateGame();

    window.dispatchEvent(new CustomEvent("analyseGameState"));

    blockUserInput = false;
  });

  // Connection to reset the word grid
  window.addEventListener("resetWordGrid", (e) => {
    gameSession = (e as CustomEvent).detail.gameSession;
    charTiles.forEach(charTile => {
      flipTile(charTile, "reset");
    });
    updateGame();
  });


  // Exchanges the read keyboard key
  window.addEventListener('keyInput', (e) => {
    if (blockUserInput) {
      return;
    }
    handleKeyboardInput((e as CustomEvent).detail.keyInput);
  });


  // Makes every char tile clickable
  charTiles?.forEach((tile, idx) => {
    tile.addEventListener('click', () => {
      if (blockUserInput || !tile.classList.contains('active')) {
        return;
      }

      cursor.selfSet = true;
      cursor.oob = false;
      cursor.removeSelection(charTiles);
      [cursor.x, cursor.y] = cursor.idxToCoord(idx);
      cursor.addSelection(charTiles);
    });
  });


  /**
   * Color codes the character tiles in the word grid.
   */
  async function charHighlighting() {
    if (gameSession.status == "return_feedback") {
      for (const i of range(WORD_LENGTH)) {
        const charIdx: number = cursor.coordToIdx(i, gameSession.guesses_used - 1);
        const color: string = gameSession.guesses[gameSession.guesses_used - 1].character_info[i].scoring;

        await flipTile(charTiles[charIdx], color);
      }
      return;
    }

    for (const i of range(gameSession.guesses_used)) {
      for (const j of range(WORD_LENGTH)) {
        const charScoring = gameSession.guesses[i].character_info[j].scoring;
        const tile = charTiles[cursor.coordToIdx(j, i)];

        const classMap: Record<string, string> = {
          green: 'char-feedback-green',
          yellow: 'char-feedback-yellow',
        };

        tile.classList.add(classMap[charScoring] || 'char-feedback-gray');
      }
    }
  }


  /**
   * Redirects a keyboard input based on its type.
   * @param key A keyboard key
   */
  function handleKeyboardInput(key: string) {
    switch(key) {
      case 'ENTER': handleEnterInput(); break;
      case 'BACKSPACE': handleBackspaceInput(); break;
      default: handleCharacterInput(key); break;
    }
    cursor.selfSet = false;
  }


  /**
   * Performs character removal if possible.
   */
  function handleBackspaceInput() {
    if ((cursor.selfSet || cursor.oob) && charTileLabels[cursor.getPos()].textContent !== '') {
      cursor.oob = false;
      charTileLabels[cursor.getPos()].textContent = '';
      cursor.addSelection(charTiles);
    } else if (cursor.x > 0) {
      charTileLabels[cursor.getPos()-1].textContent = '';
      cursor.removeSelection(charTiles);
      cursor.x--;
      cursor.addSelection(charTiles);
    } else {
      rowHeadShake();
    }
  }


  /**
   * Inserts a keyboard key into the word grid.
   * @param key a valid character
   */
  function handleCharacterInput(key: string) {
    if (cursor.oob) {
      rowHeadShake();
      return;
    }
    charTileLabels[cursor.getPos()].textContent = key.toUpperCase();
    if (cursor.x < WORD_LENGTH - 1) {
      cursor.removeSelection(charTiles);
      cursor.x++;
      cursor.addSelection(charTiles);
    } else {
      cursor.oob = true;
      cursor.removeSelection(charTiles);
    }
  }


  /**
   * Reads the characters in the current row.
   * If every tile in the row contains a character,
   * the guess is sent to the server.
   */
  function handleEnterInput() {
    const characters: string[] = [];

    for (const i of range(WORD_LENGTH)) {
      const divText: string | null = charTileLabels[cursor.coordToIdx(i, undefined)].textContent;
      characters.push(divText !== null ? divText : '');
    }

    // row is not full
    if (characters.includes('')) {
      rowHeadShake();
      return;
    }
    
    const word: string = characters.join('').toLowerCase();
    sendWord(word);
  }


  /**
   * Transmits a guessRequest event.
   * @param word Five-letter word guess
   */
  function sendWord(word: string) {
    blockUserInput = true;

    const event = new CustomEvent("submitGuess", {
      detail: {
        word: word,
      }
    });
    window.dispatchEvent(event);
  }


  /**
   * Requests the current row to run its headshake animation.
   */
  function rowHeadShake() {
    window.dispatchEvent(new CustomEvent("headShake", {
      detail: {row: gameSession.guesses_used}
    }));
  }


  /**
   * Updates the character tiles.
   */
  async function updateGame() {
    if (gameSession.current_guess_valid) {
      await charHighlighting();

      cursor.x = 0;
      cursor.oob = false;
      cursor.selfSet = false;
    }

    cursor.y = gameSession.guesses_used;
    cursor.addSelection(charTiles);
    gameSession?.guesses?.forEach((guess, rowIdx) => {
      for (const i of range(WORD_LENGTH)) {
        charTileLabels[cursor.coordToIdx(i, rowIdx)].textContent = guess.word.charAt(i).toUpperCase();
      }
    });
  }
</script>