---
import WordRow from "./wordgrid/WordRow.astro";
---

<div class="word-grid">
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
</div>

<style>
  .word-grid {
    display: flex;
    flex-direction: column;
    background-color: var(--background-color);
    width: fit-content;
    height: fit-content;
    margin: auto;
  }
</style>

<script>
  import { KEYBOARD_KEYS } from "../../lib/constants";
  import type { GameSession, Guess, Char, Scoring } from "../../lib/gameSession";
  import { requestGameSession } from "../../scripts/requestGameSession";
  import { guessRequest } from "../../scripts/guessRequest";
  import { range } from "../../lib/helpers";

  const charTiles = document.querySelectorAll('.char-tile') as NodeListOf<HTMLDivElement>;
  const charTileLabels = document.querySelectorAll('.char-tile-label') as NodeListOf<HTMLSpanElement>;
  const pageBody = document.querySelector('body') as HTMLBodyElement;


  class Cursor {
    public x: number = 0;
    public y: number = gameSession.guesses_used;
    public selfSet: boolean = false;
    public oob: boolean = false; // oob: out of bounds

    public coordToIdx(x: number = this.x, y: number = this.y): number {
      return y * 5 + x;
    }

    public idxToCoord(idx: number): number[] {
      return [idx % 5, Math.floor(idx / 5)];
    }

    public getPos(): number {
      return this.coordToIdx();
    }
  }


  /**
   * Activates the current row based on `cursor.y`
   * and deactivates all other rows.
   */
  function shiftRow(): void {
    charTiles.forEach(tile => {
      tile.classList.remove('active');
    });
    for (const i of range(5)) {
      charTiles[cursor.coordToIdx(i, undefined)].classList.add('active');
    }

    charTiles?.forEach((tile, idx) => {
      tile.addEventListener('click', () => {
        if (!tile.classList.contains('active')) return;
        cursor.selfSet = true;
        cursor.oob = false;
        removeSelectionClass();
        [cursor.x, cursor.y] = cursor.idxToCoord(idx);
        addSelectionClass();
      });
    });
  }


  function validKeyInput(key: string): boolean {
    let found: boolean = false;
    KEYBOARD_KEYS.push(['ENTER', 'BACKSPACE']);
    KEYBOARD_KEYS?.forEach(row => {
      if (row.includes(key)) found = true;
    });
    return found;
  }


  function addSelectionClass(): void {
    charTiles[cursor.getPos()]?.classList.add('char-tile-selected');
  }
  function removeSelectionClass(): void {
    charTiles[cursor.getPos()]?.classList.remove('char-tile-selected');
  }


  function handleKeyboardInput(key: string): void {
    switch(key) {
      case 'ENTER': handleEnterInput(); break;
      case 'BACKSPACE': handleBackspaceInput(); break;
      default: handleCharacterInput(key); break;
    }
    cursor.selfSet = false;
  }


  function handleBackspaceInput(): void {
    if (cursor.selfSet || charTileLabels[cursor.getPos()].textContent !== '' || cursor.oob) {
      cursor.oob = false;
      charTileLabels[cursor.getPos()].textContent = '';
      addSelectionClass();
    } else {
      charTileLabels[cursor.getPos()-1].textContent = '';
      if (cursor.x > 0) {
        removeSelectionClass();
        cursor.x--;
        addSelectionClass();
      }
    }
  }


  function handleCharacterInput(key: string): void {
    if (cursor.oob) return;
    charTileLabels[cursor.getPos()].textContent = key.toUpperCase();
    if (cursor.x <= 3) {
      removeSelectionClass();
      cursor.x++;
      addSelectionClass();
    } else {
      cursor.oob = true;
      removeSelectionClass();
    }
  }


  async function handleEnterInput(): Promise<void> {
    const characters: string[] = [];
    for (const i of range(5)) {
      const divText: string | null = charTileLabels[cursor.coordToIdx(i, undefined)].textContent;
      characters.push(divText !== null ? divText : "");
    }
    if (characters.includes('')) {
      // Invalid Enter handling...
      console.log("Not all characters are set!");
      return;
    }
    const word: string = characters.join('').toLowerCase();
    gameSession.current_guess = word;
    gameSession.status = "submit-guess";
    gameSession.current_guess_valid = false;
    gameSession = await guessRequest(gameSession);
    updateGameState();
  }


  function updateGameState(): void {
    removeSelectionClass();
    cursor = new Cursor();
    shiftRow(); // Set active word row based on GameSession
    addSelectionClass(); // Init cursor selection

    gameSession?.guesses?.forEach((guess, rowIdx) => {
      for (const i of range(5)) {
        charTileLabels[cursor.coordToIdx(i, rowIdx)].textContent = guess.word.charAt(i).toUpperCase();
      }
    });
  }


  pageBody?.addEventListener('keydown', (event) => {
    const keyInput: string = event.key.toUpperCase();
    if (!validKeyInput(keyInput)) return;
    handleKeyboardInput(keyInput);
  });


  let gameSession: GameSession = await requestGameSession();
  let cursor: Cursor = new Cursor();
  updateGameState();
</script>