---
import WordRow from "./wordgrid/WordRow.astro";
---

<div class="word-grid">
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
  <WordRow />
</div>

<style>
  .word-grid {
    display: flex;
    flex-direction: column;
    background-color: var(--background-color);
    width: fit-content;
    height: fit-content;
    margin: auto;
  }

  .game-won {
    border: 4px solid lime;
  }

  .game-lost {
    border: 4px solid red;
  }
</style>

<script>
  import { Cursor } from "../../lib/cursor";
  import type { GameSession } from "../../lib/gameSession";
  import { range } from "../../lib/helpers";

  const charTiles = document.querySelectorAll<HTMLDivElement>('.char-tile');
  const charTileLabels = document.querySelectorAll<HTMLSpanElement>('.char-tile-label');

  let gameSession: GameSession;
  const cursor: Cursor = new Cursor(0, 0, false, false);


  // Initialize the word grid after a window reload
  // and only after the data fetching is complete.
  window.addEventListener("gamePageLoaded", () => {
    initGameState();
  });

  window.addEventListener("transmitCurrentGameState", (e) => {
    const event = e as CustomEvent;
    gameSession = event.detail.gameSession;
    updateGameState();
  });

  window.addEventListener("keyInput", (e) => {
    const event = e as CustomEvent;
    handleKeyboardInput(event.detail.keyInput);
  });


  /**
   * Color codes the character tiles in the word grid.
   */
  function charHighlighting(): void {
    for (const i of range(gameSession.guesses_used)) {
      for (const j of range(5)) {
        const charScoring = gameSession.guesses[i].character_info[j].scoring;
        switch(charScoring) {
          case "green": {
            charTiles[cursor.coordToIdx(j, i)].classList.add('char-feedback-green');
            break;
          }
          case "yellow": {
            charTiles[cursor.coordToIdx(j, i)].classList.add('char-feedback-yellow');
            break;
          }
          default: {
            charTiles[cursor.coordToIdx(j, i)].classList.add('char-feedback-gray');
            break;
          }
        }
      }
    }
  }


  /**
   * Activates the current row based on `cursor.y`
   * and deactivates all other ones.
   */
  function shiftRow(): void {
    charTiles.forEach(tile => {
      tile.classList.remove('active');
    });
    for (const i of range(5)) {
      charTiles[cursor.coordToIdx(i, undefined)].classList.add('active');
    }
  }


  /**
   * Redirects a keyboard input based on its type.
   * @param key A keyboard key
   */
  function handleKeyboardInput(key: string): void {
    switch(key) {
      case 'ENTER': handleEnterInput(); break;
      case 'BACKSPACE': handleBackspaceInput(); break;
      default: handleCharacterInput(key); break;
    }
    cursor.selfSet = false;
  }


  /**
   * Performs character removal if possible.
   */
  function handleBackspaceInput(): void {
    if (cursor.selfSet || charTileLabels[cursor.getPos()].textContent !== '' || cursor.oob) {
      cursor.oob = false;
      charTileLabels[cursor.getPos()].textContent = '';
      cursor.addSelection(charTiles);
    } else if (cursor.x > 0) {
      charTileLabels[cursor.getPos()-1].textContent = '';
      cursor.removeSelection(charTiles);
      cursor.x--;
      cursor.addSelection(charTiles);
    }
  }


  /**
   * Inserts a keyboard key into the word grid.
   * @param key 
   */
  function handleCharacterInput(key: string): void {
    if (cursor.oob) return;
    charTileLabels[cursor.getPos()].textContent = key.toUpperCase();
    if (cursor.x <= 3) {
      cursor.removeSelection(charTiles);
      cursor.x++;
      cursor.addSelection(charTiles);
    } else {
      cursor.oob = true;
      cursor.removeSelection(charTiles);
    }
  }


  /**
   * Reads a word input in the current row and transmits it in a dispatch event.
   */
  function handleEnterInput(): void {
    const characters: string[] = [];

    for (const i of range(5)) {
      const divText: string | null = charTileLabels[cursor.coordToIdx(i, undefined)].textContent;
      characters.push(divText !== null ? divText : '');
    }
    if (characters.includes('')) {
      // Invalid Enter handling...
      console.log("Not all characters are set!");
      return;
    }

    const word: string = characters.join('').toLowerCase();
    sendWord(word);
  }


  /**
   * Dispatch event to fetch guessRequest
   * @param word Five-letter word guess
   */
  function sendWord(word: string): void {
    const event = new CustomEvent("guessRequest", {
      detail: {
        word: word,
      }
    });
    window.dispatchEvent(event);
  }


  function initGameState(): void {
    cursor.x = 0;
    cursor.y = gameSession.guesses_used;
    cursor.selfSet = false;
    cursor.oob = false;
    cursor.addSelection(charTiles);
    charHighlighting();
  }


  function updateGameState(): void {
    // if (gameSession.current_guess_valid) {
    //   document.querySelector('word-grid')?.classList.add('game-won');
    //   return;
    // }
    // if (gameSession.guesses_used > 5) {
    //   document.querySelector('word-grid')?.classList.add('game-lost');
    //   return;
    // }

    if (!gameSession.current_guess_valid) {
      
    } else {
      cursor.removeSelection(charTiles);
      cursor.x = 0;
      cursor.y = gameSession.guesses_used;
      cursor.oob = false;
      cursor.addSelection(charTiles);
      charHighlighting();
      shiftRow();
    }

    gameSession?.guesses?.forEach((guess, rowIdx) => {
      for (const i of range(5)) {
        charTileLabels[cursor.coordToIdx(i, rowIdx)].textContent = guess.word.charAt(i).toUpperCase();
      }
    });
  }


  charTiles?.forEach((tile, idx) => {
    tile.addEventListener('click', () => {
      if (!tile.classList.contains('active')) return;
      cursor.selfSet = true;
      cursor.oob = false;
      cursor.removeSelection(charTiles);
      [cursor.x, cursor.y] = cursor.idxToCoord(idx);
      cursor.addSelection(charTiles);
    });
  });
</script>